
Our toolkit allows for binary and malware analysis. 
For manual analysis, the following directories are particularly important:
- `/pintool`
The `pintoo` directory contains our **PinTool**, a utility that instruments binaries (with intel pin) to create detailed execution traces. These traces serve as a resource for your analytical efforts.
- `/python-puppeteer/puppeteering/poi`
 They analyze the execution traces generated by PinTool, identifying instructions and memory addresses of searched patterns. 


## 1. Compiling the Pintool

### 1.1 Compilation with Visual Studio

1. Open the project `/pintool/PuppeteeringPintool.sln` in Visual Studio.
2. Ensure the Windows Path is correctly set:
   - Right-click the PuppeteeringPintool project -> properties -> C/C++ -> Preprocessor definitions
   - Set `_WINDOWS_H_PATH_` to `C:/Program Files (x86)/Windows Kits/10/include/{YOUR VERSION}/um` (e.g., `10.0.19041.0`).


### 1.2 Compilation with Cygwin
1. Run via:
    `.\setup-x86.exe --allow-unsupported-windows --site http://ctm.crouchingtigerhiddenfruitbat.org/pub/cygwin/circa/2022/11/23/063457`
    - Install `make`
    - Add cygwin `bin` to PATH
2. Extract Pin 3.19 (MSVC Version) to the root of this folder and rename the folder: `pin-3.19-...` -> `pin`
(https://software.intel.com/sites/landingpage/pintool/downloads/pin-3.19-98425-gd666b2bee-msvc-windows.zip)
3. Install Visual Studio **2019** for the MSVC Compiler (IDE is not required). Required components:
    - MSVC v142 - VS 2019 C++ x64/x86 build tools (Latest) *Required for compilation*
    - Windows 10 SDK (Latest) *Required for Windows headers; Backward compatible with Windows 7*
4. Start the "Developer Command Prompt for VS 2019". Only the the require `cl` compiler is available
5. Go into the `pintool` Folder and create the `pintool\obj-ia32\utils` subfolder.
6. Run `make` - the Pintool DLL is compilet at `pintool\obj-ia32\PuppetPintool.dll`

---


## 2. Using the Pintool: Example with Locky on Windows 7 32-Bit VM

### 2.1 Required Tools
*For ACSAC reviewer we provide a VM. You should have a link in the Artifact Abstract. Otherwise just write us. To make it easier we used snapshots using VMware Workstation. You can download a trial here: https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html*

Before using the Pintool, make sure the following tools are loaded onto your Windows 7 32-Bit VM:
1. Intel Pin
2. Pintool
3. Procmon
4. Process Hacker

*ACSAC: After this step you are at snapshot `ACSAC-Tools` in the provided VM*

### 2.2 Obtaining execution traces
1. Start Procmon, Process Hacker, and then Locky.
2. Allow Locky to encrypt files (observe in Procmon).
3. Suspend Locky in Process Hacker.
*ACSAC: After this step you are at snapshot `ACSAC-Suspend` in the provided VM*

4. Attach the pintool using `pin.exe -pid XXX -t t-32-r.dll -trace ransomware-locky-trace -trace_non_image 1 -ins_log ransomware-locky-ins-log`
5. Unsuspend Locky.
3. Wait for Locky to encrypt a few (1-3) files.
4. Suspend Locky again.
5. The pintool should have generated two files. The tracefile `ransomware-locky-trace`. The instruction information file `ransomware-locky-ins-log` containing the instruction pointer and the instruction in ASM.
*ACSAC: After this step you are at snapshot `ACSAC-Encrypted` in the provided VM*

---
## 3. Analyzing the execution trace
### 3.1 Analyzing
In the example of Locky ransomware, you can locate all the relevant files within [/python-puppeteer/locky-trace-data](/python-puppeteer/locky-trace-data):
- The execution trace archive: `ransomlocky_trace.zip` (unzip this file first)
- The instruction log: `ransomlocky_ins_log.1772`
- The cleartext file: `test_iarg_preserve_app.cpp`
- The encrypted file: `SHZIPMYC--IJMX--0TAQ--97AC0A23--BDADB310A222.osiris`
- The unpacked Locky module: `locky-ent.exe_0x300000_pw_acsacinfected.zip` (password protected)

 
1. Identifying Search Bytes from the cleartext and encrypted File
   1. Open the encrypted file `python-puppeteer/locky-trace-data/SHZIPMYC--IJMX--0TAQ--97AC0A23--BDADB310A222.osiris`, and extract the first N bytes: `D0912F9D`.
   2. Use VM rollbacks to obtain the cleartext content of the encrypted file `python-puppeteer/locky-trace-data/test_iarg_preserve_app.cpp`. Choose some bytes, e.g., `466c6431` (hexadecimal for "Fld1").
   3. Note that Locky processes file content in batches of approximately 16 bytes. If you select bytes that span two different batches, you'll get no results in the next step. So, use content from the beginning of the file or different snippets.

2. Run the python analyzer `python -m puppeteering.poi.memory_pattern_extractor add $PATTERN $PATTERNNAME file ABSOLUTE_PATH_TO_TRACE_FILE`
    - Pattern is the pattern to search for (byte encoded `44AB`)
    - Patternname is the name you give the pattern.
    - For the example, unzip `python-puppeteer\locky-trace-data\ransomlocky_trace.zip` and then run from `python-puppeteer` `python -m puppeteering.poi.memory_pattern_extractor add 466c6431 cleartext add D0912F9D Ciphertext file python-puppeteer\locky-trace-data\ransomlocky_trace\ransomlocky.1772 1 lockypois.json poi_details.log`

*For the locky example the result files can be found in [/python-puppeteer/locky-analyzer-output](/python-puppeteer/locky-analyzer-output)*
- the found and rated POIs `lockypois.json`
- the POI details log, containing the memory the POI instruction accessed (helps for furhter analysis) `poi_details.log`

### 3.2 Validating found POIs
#### 3.2.1 Bare Validation
1. The previous step should obtained some POIs. Open the instruction log `ransomlocky_ins_log.1772`
2. Calculate the adresses to decimal, search for the address. See if they are instructions that are interesing, i.e., instructions that are located in a non-OS module or in no module at all.
Locky example: Loading memory, xoring with something, writing memory. Might be an encryption routine
    ```
    3153540;437;MOVDQU;movdqu xmm5, xmmword ptr [edi]; // POI Cleartext
    3153544;678;PXOR;pxor xmm0, xmm5;
    3153548;437;MOVDQU;movdqu xmmword ptr [edi], xmm0; // POI Ciphertext
    ```
3. Check the output of `poi_details.log` what those instructions additionally accsessed

#### 3.2.2 Validation in IDA/Ghidra
0. Obtain the binary to be analyzed. Dump the memory region using tools like ProcessHacker (right-click on locky.exe, properties, memory). Identify the region where the POIs are found (e.g., 0x300000 with size 156kB RWX). Save the memory dump (e.g., `locky-ent.exe_0x300000_pw_acsacinfected.zip`).
Note that are not in any registered module of locky but a raw memory region. 
1. Load the dumped memory/executable into Ghidra/IDA. Pay attention to rebase the program as needed. Note that sometimes an additional offset is required. For instance, if your sample (the provided sample) has an offset of 0xC00, rebase to 0x300000 - 0xC00 = `0x2FF400`.
2. Use the provided IDA/Ghidra Python script [/plugins/ida.py](/plugins/ida.py) to import the POIs.


---
## 4. Botnet Monitoring
The proposed approach for automated botnet monitoring is outlined as follows:
- Identification of IPs and ports accessed by a botnet using network monitoring techniques.
- Utilization of these identified IPs and ports as inputs for the Point of Interest (POI) search.
- Extraction of high-quality (highly rated) POIs and subsequent monitoring of their activities to uncover additional accessed resources. This process aids in the extraction of new peers (IPs, ports).

To conduct our assessment, a localized botnet environment has been established. This involved the integration of multiple virtual machines (VMs) and a router VM within a network. The virus-infected VMs were allowed to establish connections through the network. Subsequently, the malware's behavior was tracked using Intel Pin, generating a trace. This trace was then used to extract new peers.

The project encompasses a suite of scripts designed to automate various tasks, including VM setup, pausing, snapshot creation, and reset procedures on a Proxmox node. For preliminary and infrequent testing purposes, we recommend the manual setup of the local botnet, followed by the instrumentation of malware using the Pintool and anylsis of the `poi_details.log`.


## VM Setup
- Windows 7 Ultimate/Pro SP1 32 bit
- VMware Tools 11.1.0:
https://packages.vmware.com/tools/releases/11.1.0/windows/
(https://kb.vmware.com/s/article/78708)

**Steps that worked for our Windows ISO:**
- Update to SP1 (original ISO was non-SP1)
- Install KB3102810-x86
- Install Windows Updates
- (Disable Windows Defender)

**Installation:**
- Python 3 (3.8.10 for Windows 7 support)
- Cygwin
    - Run via:
    `.\setup-x86.exe --allow-unsupported-windows --site http://ctm.crouchingtigerhiddenfruitbat.org/pub/cygwin/circa/2022/11/23/063457`
    - Install `make`
    - Add cygwin `bin` to PATH
- Extract Pin 3.19 (MSVC Version) to the root of this folder and rename the folder: `pin-3.19-...` -> `pin`
(https://software.intel.com/sites/landingpage/pintool/downloads/pin-3.19-98425-gd666b2bee-msvc-windows.zip)
- Install Visual Studio **2019** for the MSVC Compiler (IDE is not required). Required components:
    - MSVC v142 - VS 2019 C++ x64/x86 build tools (Latest) *Required for compilation*
    - Windows 10 SDK (Latest) *Required for Windows headers; Backward compatible with Windows 7*

## Compiling the Pintool
- Start the "Developer Command Prompt for VS 2019". Only the the require `cl` compiler is available
- Go into the `pintool` Folder and create the `pintool\obj-ia32\utils` subfolder.
- Run `make` - the Pintool DLL is compilet at `pintool\obj-ia32\PuppetPintool.dll`

## Automated Botnet Analysis ("Puppeteer")
In the following, we give a high-level overview over the automated botnet analysis. It consists of the following components:
- **AnalysisPackage**: Contains the botnet malware itself and the parameters needed to launch it. See [/analysis-packages/](/analysis-packages/) for some examples.
- [**Agent**](/python-puppeteer/agent.py):
    - Must be installed on the "infected" VM.
    - Is controlled via [*RPyC*](https://rpyc.readthedocs.io) -- usually by the **Puppeteer**.
    - Dumps an interface given by the `DUMPIF` environment variable using [`dumpcap`](https://www.wireshark.org/docs/man-pages/dumpcap.html).
    - Runs an analysis package, i.e., analyzes a malware with our Pintool (`PINPATH` and `PINTOOL` environment variables must be set).
    - Communicates with the running Pintool via IPC -- this is used to get a live trace of called network functions (e.g., `sendto` and `connect`). All calls to these network functions are sent to the **Puppeteer** via *RPyC*.
    - Can dump the malware process via [*Process Dump*](https://github.com/glmcdona/Process-Dump).
- **Router**: We have used -- by now EOL -- [*Zeroshell*](https://www.zeroshell.org/); however, any iptables based router should work. The router must ...
    - ... give the **Puppeteer** access to the **Agent** VM via *RPyC* (per default, listens in port 12345).
    - ... give the **Agent** VM access to a botnet for the given botnet malware. Can, for example, be a local botnet (see below) or real-world (via the Internet).
    - ... be reconfigurable by the **Puppeteer**
- [**Puppeteer**](/python-puppeteer/auto_puppeteer.py):
    - Controls the **Agent** VM via the Proxmox API, rolling it back to a known good state where the agent is running and no malware is installed at the start of each analysis.
    - Communicates via *RPyC* with the **Agent**.
    - Has a [configuration file](/python-puppeteer/evaluation_logging.conf).
    - Analyzes the results (log-files) produced on the **Agent** VM by our Pintool.

Based on this, the basic setup is as follows:
- **Agent** VM:
    - Disable Windows Defender and Firewall.
    - Install Wireshark. Folder containing `dumpcap` must be in `PATH`.
    - "Install" [*Process Dump*](https://github.com/glmcdona/Process-Dump) and make `pd32.exe` available via `PATH`.
    - Start `agent.py` (install [agent_requirements.txt](/python-puppeteer/agent_requirements.txt) beforehand).
    - Create live snapshot once the **Agent** is running.
- **Router**:
    - Configure it as described above and give the **Puppeteer** access via SSH.
- Analysis Machine:
    - Configure the Puppeteer to you liking (options documented in the [auto_puppeteer.py](/python-puppeteer/auto_puppeteer.py)).
    - Run the Puppeteer.